library(xts)
library(vars)
library(tidyverse)
library(knitr)
library(urca)
library(tseries)
file_path <- file.choose()
data <- read.csv(file_path)
# Loop through all time series and perform the ADF test
for(i in 1:10) {
adf.test(data[,i])
}
# Initialize variables to hold the cointegrated pair
pair_found <- FALSE
pair <- c()
# Loop through all pairs of time series and perform the cointegration test
for(i in 1:9) {
for(j in (i+1):10) {
test <- cointegrationTest(data[,i], data[,j], output=FALSE)
if(test@test$p.value < 0.05) {
pair_found <- TRUE
pair <- c(i, j)
break
}
}
if(pair_found) {
break
}
}
if(pair_found) {
cat("Cointegrated pair found:", colnames(data)[pair], "\n")
} else {
cat("No cointegrated pair found.\n")
}
library(forecast)
library(vars)
library(tidyverse)
library(knitr)
library(urca)
library(tseries)
library(xts)
data <- read.csv("TSA_2023.csv")
data$Date <- as.Date(data[, 1])
# Perform ADF test for each variable
adf_results <- lapply(data[-1], adf.test)
# Extract the test statistics and p-values
adf_stats <- sapply(adf_results, function(x) x$statistic)
adf_pvalues <- sapply(adf_results, function(x) x$p.value)
# Print the ADF test results for each variable
for (i in seq_along(adf_results)) {
cat("ADF Test Results for", colnames(data)[i+1], ":\n")
cat("Test statistic:", adf_stats[i], "\n")
cat("p-value:", adf_pvalues[i], "\n\n")
}
# Perform the ADF test for x4
x4 <- data$x4
adf_result_x4 <- adf.test(x4)
# Check the ADF test results for x4
cat("ADF Test Results for x4:\n")
cat("Test statistic:", adf_result_x4$statistic, "\n")
cat("p-value:", adf_result_x4$p.value, "\n\n")
# Create a time series object with the date index
x4_ts <- ts(data[, 2], start = min(data$Date), end = max(data$Date), frequency = 12)
# Perform seasonal decomposition of x4
decomposition <- decompose(x4_ts)
# Plot the seasonal decomposition
plot(decomposition)
# Check for seasonality using seasonal plots
seasonplot(x4_ts)
# Examine the autocorrelation function (ACF) and partial autocorrelation function (PACF)
acf(x4_ts)
pacf(x4_ts)
ggseasonplot(x4_ts)
ggseasonplot(x4_ts)
# Examine the autocorrelation function (ACF) and partial autocorrelation function (PACF)
acf(x4_ts)
pacf(x4_ts)
ggseasonplot(x4_ts)
library(forecast)
library(vars)
library(tidyverse)
library(knitr)
library(urca)
library(tseries)
library(xts)
data <- read.csv("TSA_2023.csv")
data$Date <- as.Date(data[, 1])
# Perform ADF test for each variable
adf_results <- lapply(data[-1], adf.test)
# Extract the test statistics and p-values
adf_stats <- sapply(adf_results, function(x) x$statistic)
adf_pvalues <- sapply(adf_results, function(x) x$p.value)
# Print the ADF test results for each variable
for (i in seq_along(adf_results)) {
cat("ADF Test Results for", colnames(data)[i+1], ":\n")
cat("Test statistic:", adf_stats[i], "\n")
cat("p-value:", adf_pvalues[i], "\n\n")
}
# Perform the ADF test for x4
x4 <- data$x4
adf_result_x4 <- adf.test(x4)
# Check the ADF test results for x4
cat("ADF Test Results for x4:\n")
cat("Test statistic:", adf_result_x4$statistic, "\n")
cat("p-value:", adf_result_x4$p.value, "\n\n")
# Create a time series object with the date index
x4_ts <- ts(data[, 2], start = min(data$Date), end = max(data$Date), frequency = 12)
# Perform seasonal decomposition of x4
decomposition <- decompose(x4_ts)
# Plot the seasonal decomposition
plot(decomposition)
# Check for seasonality using seasonal plots
seasonplot(x4_ts)
# Check for seasonality using seasonal plots
seasonplot(x4_ts)
ggseasonplot(x4_ts)
# Examine the autocorrelation function (ACF) and partial autocorrelation function (PACF)
acf(x4_ts)
pacf(x4_ts)
# Fit a model to x4 (replace 'model' with your chosen model)
model <- arima(x4, order = c(p, d, q))
# Fit a model to x4 (replace 'model' with your chosen model)
model <- arima(x4, order = c(2, d, q))
# Fit a model to x4 (replace 'model' with your chosen model)
model <- arima(x4, order = c(2, 1, 1))
# Obtain the residuals from the model
residuals <- residuals(model)
# Perform the Ljung-Box test on the residuals
lb_test <- Box.test(residuals, lag = lag_value, type = "Ljung-Box")
# Perform the Ljung-Box test on the residuals
lb_test <- Box.test(residuals, lag = 2, type = "Ljung-Box")
# Extract the test statistic and p-value
test_statistic <- lb_test$statistic
p_value <- lb_test$p.value
# Print the Ljung-Box test results
cat("Ljung-Box Test Results:\n")
cat("Test statistic:", test_statistic, "\n")
cat("p-value:", p_value, "\n\n")
monthplot(x4_ts)
# Perform the ADF test for x4
x4 <- data$x4
adf_result_x4 <- adf.test(x4)
# Check the ADF test results for x4
cat("ADF Test Results for x4:\n")
cat("Test statistic:", adf_result_x4$statistic, "\n")
cat("p-value:", adf_result_x4$p.value, "\n\n")
# Combine the non-stationary variables into a matrix
data_matrix <- cbind(x1, x2, x3, x5, x6, x7, x8, x9, x10)
testdf(variable = ppi_cpi$ppi,
max.augmentations = 3)
# Combine the non-stationary variables into a matrix
x1 <- data$x1
x2 <- data$x2
x3 <- data$x3
x5 <- data$x5
x5 <- data$x5
# Combine the non-stationary variables into a matrix
x1 <- data$x1
x2 <- data$x2
x3 <- data$x3
x5 <- data$x5
x6 <- data$x6
x7 <- data$x7
x8 <- data$x8
x9 <- data$x9
# Combine the non-stationary variables into a matrix
x1 <- data$x1
library(forecast)
library(vars)
library(tidyverse)
library(knitr)
library(urca)
library(tseries)
library(xts)
data <- read.csv("TSA_2023.csv")
data$Date <- as.Date(data[, 1])
# Perform ADF test for each variable
adf_results <- lapply(data[-1], adf.test)
# Extract the test statistics and p-values
adf_stats <- sapply(adf_results, function(x) x$statistic)
adf_pvalues <- sapply(adf_results, function(x) x$p.value)
# Print the ADF test results for each variable
for (i in seq_along(adf_results)) {
cat("ADF Test Results for", colnames(data)[i+1], ":\n")
cat("Test statistic:", adf_stats[i], "\n")
cat("p-value:", adf_pvalues[i], "\n\n")
}
# Perform the ADF test for x4
x4 <- data$x4
adf_result_x4 <- adf.test(x4)
# Check the ADF test results for x4
cat("ADF Test Results for x4:\n")
cat("Test statistic:", adf_result_x4$statistic, "\n")
cat("p-value:", adf_result_x4$p.value, "\n\n")
# Create a time series object with the date index
x4_ts <- ts(data[, 2], start = min(data$Date), end = max(data$Date), frequency = 12)
# Perform seasonal decomposition of x4
decomposition <- decompose(x4_ts)
# Plot the seasonal decomposition
plot(decomposition)
# Check for seasonality using seasonal plots
seasonplot(x4_ts)
ggseasonplot(x4_ts)
monthplot(x4_ts)
# Examine the autocorrelation function (ACF) and partial autocorrelation function (PACF)
acf(x4_ts)
pacf(x4_ts)
# Combine the non-stationary variables into a matrix
x1 <- data$x1
x2 <- data$x2
x3 <- data$x3
x5 <- data$x5
x6 <- data$x6
x7 <- data$x7
x8 <- data$x8
x9 <- data$x9
x10 <- data$x10
data_matrix <- cbind(x1, x2, x3, x5, x6, x7, x8, x9, x10)
# Perform Johansen cointegration test
johansen_result <- ca.jo(data_matrix, type = "trace", ecdet = "none")
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "trace"]
# Extract the test results
johansen_trace_stat <- johansen_result$r0
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "lambda"]
johansen_critical_values <- johansen_result@cval[, , "trace"]
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "statistic"]
johansen_critical_values <- johansen_result@cval[, , "10%", drop = FALSE]
# Perform Johansen cointegration test
johansen_result <- ca.jo(data_matrix, type = "trace", ecdet = "none")
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "statistic"]
johansen_critical_values <- johansen_result@cval[, , "10%", drop = FALSE]
# Extract the test results
johansen_trace_stat <- johansen_result@trace@teststat
johansen_critical_values <- johansen_result@trace@cval
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "lambda"]
johansen_critical_values <- johansen_result@cval[, , "10%", drop = FALSE]
# Select the relevant variables for cointegration analysis
variables <- data[, c("x1", "x2", "x3", "x5", "x6", "x7", "x8", "x9", "x10")]
# Perform the Johansen cointegration test
johansen_result <- ca.jo(variables, type = "trace", K = 2, ecdet = "none", spec = "longrun")
# Extract the test results
johansen_trace_stat <- johansen_result@teststat[, "lambda"]
johansen_critical_values <- johansen_result@cval[, , "10%", drop = FALSE]
summary(jotest)
summary(johansen_result)
# Select the relevant variables for cointegration analysis
variables <- data[, c("x1", "x2", "x3", "x4, " "x5", "x6", "x7", "x8", "x9", "x10")]
# Select the relevant variables for cointegration analysis
variables <- data[, c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10")]
# Perform the Johansen cointegration test
johansen_result <- ca.jo(variables, type = "trace", K = 2, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Assuming you have your data stored in a matrix 'data'
# Create a VAR model with a maximum lag order of 'max_k'
var_model <- VAR(data, p = max_k, type = "const")
# Assuming you have your data stored in a matrix 'data'
# Set the maximum lag order you want to consider
max_k <- 10
# Create a VAR model with a maximum lag order of 'max_k'
var_model <- VAR(data, p = max_k, type = "const")
# Create a VAR model with a maximum lag order of 'max_k'
var_model <- VAR(variables, p = max_k, type = "const")
# Get the AIC values for lag orders from 1 to 'max_k'
aic_values <- sapply(1:max_k, function(k) AIC(var_model$VAR[k]))
# Get the AIC values for lag orders from 1 to 'max_k'
aic_values <- sapply(1:max_k, function(k) AIC(var_model$VAR[k]))
# Estimate the VAR model
var_fit <- fit(var_model)
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(data, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
library(vars)
# Assuming you have your data stored in a matrix 'data'
# Set the maximum lag order you want to consider
max_k <- 10
# Create a VAR model with a maximum lag order of 'max_k'
var_model <- VAR(variables, p = max_k, type = "const")
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(data, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
library(vars)
# Assuming you have your data stored in a matrix 'data'
# Set the maximum lag order you want to consider
max_k <- 10
# Create a VAR model with a maximum lag order of 'max_k'
var_model <- VAR(variables, p = max_k, type = "const")
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(data, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
# Find the lag order with the minimum AIC
min_aic <- min(aic_values)
best_k <- which.min(aic_values)
# Print the AIC values and the lag order with the minimum AIC
cat("AIC values:", "\n")
print(aic_values)
cat("\n")
cat("Best lag order (minimum AIC):", best_k, "\n")
# Assuming you have your data stored in a matrix 'data'
# Set the maximum lag order you want to consider
max_k <- 10
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(variables, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
# Find the lag order with the minimum AIC
min_aic <- min(aic_values)
best_k <- which.min(aic_values)
# Print the AIC values and the lag order with the minimum AIC
cat("AIC values:", "\n")
print(aic_values)
cat("\n")
cat("Best lag order (minimum AIC):", best_k, "\n")
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform ADF test for each variable
adf_results <- lapply(data[-1], adf.test)
# Extract the test statistics and p-values
adf_stats <- sapply(adf_results, function(x) x$statistic)
adf_pvalues <- sapply(adf_results, function(x) x$p.value)
# Print the ADF test results for each variable
for (i in seq_along(adf_results)) {
cat("ADF Test Results for", colnames(data)[i+1], ":\n")
cat("Test statistic:", adf_stats[i], "\n")
cat("p-value:", adf_pvalues[i], "\n\n")
}
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(variables, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
# Find the lag order with the minimum AIC
min_aic <- min(aic_values)
best_k <- which.min(aic_values)
# Print the AIC values and the lag order with the minimum AIC
cat("AIC values:", "\n")
print(aic_values)
cat("\n")
cat("Best lag order (minimum AIC):", best_k, "\n")
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Select the relevant variables
variables <- data[, c("x1", "x2", "x3", "x5", "x6", "x7", "x8", "x9", "x10")]
# Perform ADF test for each variable
adf_results <- lapply(data[-1], adf.test)
# Extract the test statistics and p-values
adf_stats <- sapply(adf_results, function(x) x$statistic)
adf_pvalues <- sapply(adf_results, function(x) x$p.value)
# Print the ADF test results for each variable
for (i in seq_along(adf_results)) {
cat("ADF Test Results for", colnames(data)[i+1], ":\n")
cat("Test statistic:", adf_stats[i], "\n")
cat("p-value:", adf_pvalues[i], "\n\n")
}
# Perform the ADF test for x4
x4 <- data$x4
adf_result_x4 <- adf.test(x4)
# Check the ADF test results for x4
cat("ADF Test Results for x4:\n")
cat("Test statistic:", adf_result_x4$statistic, "\n")
cat("p-value:", adf_result_x4$p.value, "\n\n")
# Create a time series object with the date index
x4_ts <- ts(data[, 2], start = min(data$Date), end = max(data$Date), frequency = 12)
# Perform seasonal decomposition of x4
decomposition <- decompose(x4_ts)
# Plot the seasonal decomposition
plot(decomposition)
# Check for seasonality using seasonal plots
seasonplot(x4_ts)
ggseasonplot(x4_ts)
monthplot(x4_ts)
# Examine the autocorrelation function (ACF) and partial autocorrelation function (PACF)
acf(x4_ts)
pacf(x4_ts)
# Assuming you have your data stored in a matrix 'data'
# Set the maximum lag order you want to consider
max_k <- 10
# Estimate the VAR model for lag orders from 1 to 'max_k'
var_models <- lapply(1:max_k, function(k) VAR(variables, p = k, type = "const"))
# Calculate the AIC values for each VAR model
aic_values <- sapply(var_models, function(model) AIC(model))
# Find the lag order with the minimum AIC
min_aic <- min(aic_values)
best_k <- which.min(aic_values)
# Print the AIC values and the lag order with the minimum AIC
cat("AIC values:", "\n")
print(aic_values)
cat("\n")
cat("Best lag order (minimum AIC):", best_k, "\n")
# Perform the Johansen cointegration test with best lag from AIC
x <- data[, c("x1", "x2", "x3", "x4", "x5", "x6", "x7", "x8", "x9", "x10")]
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 2, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 4, ecdet = "none", spec = "longrun")
summary(johansen_result)
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
# Perform the Johansen cointegration test with best lag from AIC
johansen_result <- ca.jo(variables, type = "trace", K = 5, ecdet = "none", spec = "longrun")
library(forecast)
